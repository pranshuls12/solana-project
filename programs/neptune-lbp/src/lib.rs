use anchor_lang::prelude::*;
mod instructions;
mod logExpMath;
mod math;
mod state;
mod utils;
use instructions::*;
use logExpMath::*;
use math::WeightedMathTrait; // Adjust based on actual trait name
use utils::*;

use anchor_spl::associated_token::{self, Create};
use anchor_spl::token::{self, Burn, InitializeMint, MintTo, Transfer, TransferChecked};
use num::bigint::BigInt;
use solana_maths::{MathError, U128, U192}; //Precision lib for scaled amount
use solana_program::clock::{Clock, UnixTimestamp};

declare_id!("3Wxsikr3N9wJAiKcHfHD5ALyYEogkiGTi2u6nUFm5x3F");

#[program]
pub mod neptune_lbp {
    use super::*;

    /// Initialize a Master Account
    ///
    /// This function sets up a new master account with initial configurations for a protocol. It specifies the account type, version, admin, protocol fees, and the fee collector.
    ///
    /// # Arguments
    ///
    /// * `ctx` - A Context object containing references to the accounts needed for initialization.
    /// * `fee_collector` - The public key of the account designated to collect fees generated by the protocol.
    ///
    /// # Accounts
    ///
    /// * `master_account` - The master account to be initialized. This account stores the protocol's main configuration.
    /// * `admin` - The admin account, acting as the payer for the initialization and the administrative authority for the master account.
    /// * `system_program` - A reference to the System Program, used for creating and managing accounts on the blockchain.
    ///
    /// # Process
    ///
    /// 1. Sets the master account's type to `1` to indicate its role within the protocol.
    /// 2. Initializes the master account with a version of `0`.
    /// 3. Assigns the provided `admin` account's public key as the admin of the master account.
    /// 4. Sets the protocol's swap fee percentage to `2%`. This fee is applied to participants buying into the pool.
    /// 5. Sets the protocol's flat rate fee percentage to `3%`. This is a collateral token fee taken at the finalization of the pool.
    /// 6. Links the `fee_collector` account as the recipient of the collected fees.
    ///
    pub fn initialize(ctx: Context<Initialize>, fee_collector: Pubkey) -> Result<()> {
        let master_account = &mut ctx.accounts.master_account;
        master_account.account_type = 1;
        master_account.version = 0;
        master_account.admin = ctx.accounts.admin.key();
        //2% swap fee that is paid by participants who buy into the pool.
        master_account.protocol_swap_fee_percentage = 2u8;
        //flat rate of collateral token taken at finalization of the pool
        master_account.protocol_flat_rate_percentage = 3u8;
        master_account.fee_collector = fee_collector;

        Ok(())
    }

    /// Set Protocol Fee Percentages
    ///
    /// This function updates the fee percentages for the protocol, including both the swap fee percentage and the flat rate fee percentage. These fees apply to transactions within the protocol.
    ///
    /// # Arguments
    ///
    /// * `ctx` - A Context object containing references to the accounts needed for setting fees.
    /// * `swap_fee` - The new swap fee percentage to be applied to participants who buy into the pool.
    /// * `flat_rate` - The new flat rate percentage of collateral token to be taken at the finalization of the pool.
    ///
    /// # Accounts
    ///
    /// * `master_account` - The master account whose fee settings are to be updated. Must be authorized by the admin account.
    /// * `admin` - The admin account, acting as the payer for the transaction and the administrative authority for the master account.
    /// * `system_program` - A reference to the System Program, used for account management.
    ///
    /// # Process
    ///
    /// 1. Validates that the `admin` account provided in the context has authority over the `master_account`.
    /// 2. Updates the `master_account`'s swap fee percentage to the value specified by `swap_fee`.
    /// 3. Updates the `master_account`'s flat rate fee percentage to the value specified by `flat_rate`.
    pub fn set_fee_percentage(ctx: Context<SetFees>, swap_fee: u8, flat_rate: u8) -> Result<()> {
        let master_account = &mut ctx.accounts.master_account;
        //2% swap fee that is paid by participants who buy into the pool.
        master_account.protocol_swap_fee_percentage = swap_fee;
        //flat rate of collateral token taken at finalization of the pool
        master_account.protocol_flat_rate_percentage = flat_rate;
        Ok(())
    }

    /// Set Fee Collector
    ///
    /// This function updates the fee collector account for the protocol. The fee collector account is where collected fees are deposited.
    ///
    /// # Arguments
    ///
    /// * `ctx` - A Context object containing references to the accounts needed for setting the fee collector.
    /// * `fee_collector` - The public key of the new fee collector account.
    ///
    /// # Accounts
    ///
    /// * `master_account` - The master account whose fee collector setting is to be updated. Must be authorized by the admin account.
    /// * `admin` - The admin account, acting as the payer for the transaction and the administrative authority for the master account.
    /// * `system_program` - A reference to the System Program, used for account management.
    ///
    /// # Process
    ///
    /// 1. Validates that the `admin` account provided in the context has authority over the `master_account`.
    /// 2. Updates the `master_account`'s fee collector to the new public key specified by `fee_collector`.
    pub fn set_fee_collector(ctx: Context<SetCollector>, fee_collector: Pubkey) -> Result<()> {
        // only authaurized admin check using anchor

        let master_account = &mut ctx.accounts.master_account;
        master_account.fee_collector = fee_collector;

        Ok(())
    }

    /// Collect Fees from Associated Token Account (ATA)
    ///
    /// This function transfers all tokens from the master account's ATA to the fee collector's ATA. It is designed to facilitate the collection of accumulated fees in the form of tokens.
    ///
    /// # Arguments
    ///
    /// * `ctx` - A Context object containing references to the accounts needed for collecting fees.
    ///
    /// # Accounts
    ///
    /// * `master_account` - The master account associated with the fees to be collected. It must be authorized by the fee collector.
    /// * `fee_collector` - The fee collector account, acting as the authority for the fee collection process.
    /// * `fee_collector_token_ata` - The fee collector's associated token account where the fees will be deposited.
    /// * `master_account_token_ata` - The master account's associated token account from which the fees will be withdrawn.
    /// * `token_mint` - The token mint account for the tokens being transferred.
    /// * `associated_token_program` - A reference to the Associated Token Program, used for working with associated token accounts.
    /// * `token_program` - A reference to the Token Program, used for executing the token transfer.
    /// * `system_program` - A reference to the System Program, used for account management.
    ///
    /// # Process
    ///
    /// 1. Validates that the `fee_collector` account has authority to collect fees from the `master_account`.
    /// 2. Prepares the CPI (Cross-Program Invocation) context for the token transfer, using the associated token accounts and the authority of the `master_account`.
    /// 3. Executes the token transfer from the `master_account_token_ata` to the `fee_collector_token_ata`, transferring the entire balance of the `master_account_token_ata`.
    pub fn collect_fees_from_ata(ctx: Context<CollectFees>) -> Result<()> {
        // only authaurized fee_collector check using anchor
        let bump = ctx.bumps.master_account;
        let bump_seed = [bump]; // Make sure bump is a single byte
        let seeds = &[
            b"master_account",
            &bump_seed[..], // Include the bump seed as part of the seeds array
        ];
        let signer: &[&[&[u8]]] = &[seeds];
        if ctx.accounts.master_account_token_ata.to_account_info().key != &Pubkey::default() {
            let master_account = &mut ctx.accounts.master_account;
            let transfer_fees_cpi_accounts = Transfer {
                from: ctx.accounts.master_account_token_ata.to_account_info(),
                to: ctx.accounts.fee_collector_token_ata.to_account_info(),
                authority: ctx.accounts.master_account.to_account_info(),
            };

            let transfer_fees_cpi_ctx = CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                transfer_fees_cpi_accounts,
                signer,
            );
            token::transfer(
                transfer_fees_cpi_ctx,
                ctx.accounts.master_account_token_ata.amount,
            )?;
        } else {
            // Perform SOL transfer if the output token is indeed SOL
            let lamports_to_transfer: u64 = **ctx
                .accounts
                .master_account
                .to_account_info()
                .lamports
                .borrow();
            utils::transfer_router(
                true, // This is a SOL transfer
                None, // Token program not required for SOL
                ctx.accounts.master_account.to_account_info(),
                // Source account: User's wallet for SOL
                None, // Mint account not applicable for SOL
                ctx.accounts.fee_collector.to_account_info(),
                // Destination: Pool's output account capable of receiving SOL
                Some(ctx.accounts.master_account.to_account_info()), // Authority: User, as the signer
                Some(signer),         // Signer seeds: None, direct signing by the user
                lamports_to_transfer, // Amount: The SOL amount to transfer, in lamports
                None,                 // Decimals not applicable for SOL
                Some(ctx.accounts.system_program.to_account_info()), // System program required for SOL transfers
            )?;
        }
        Ok(())
    }

    /// Set Admin
    ///
    /// Updates the admin of the master account. This function changes the administrative authority to a new account.
    ///
    /// # Arguments
    ///
    /// * `ctx` - A Context object containing references to the accounts needed for the admin update.
    /// * `admin` - The public key                                                                                              of the new admin account.
    ///
    /// # Accounts
    ///
    /// * `master_account` - The master account for which the admin is being changed. Must be authorized by the current admin account.
    /// * `admin` - The current admin account, acting as the payer for the transaction and providing authorization for the change.
    /// * `system_program` - A reference to the System Program, used for account management.
    ///
    /// # Process
    ///
    /// 1. Validates that the current `admin` account provided in the context has authority over the `master_account`.
    /// 2. Updates the `master_account`'s admin to the new public key specified by `admin`.
    pub fn set_admin(ctx: Context<SetAdmin>, admin: Pubkey) -> Result<()> {
        // only authaurized admin check using anchor
        let master_account = &mut ctx.accounts.master_account;
        master_account.admin = admin;

        Ok(())
    }

    /// Calculate Invariant Instruction
    ///
    /// This function is designed for integration testing and calculates the invariant value based on provided weights and balances. It demonstrates the usage of weighted math operations in a restricted two-element context.
    ///
    /// # Arguments
    ///
    /// * `ctx` - A Context object containing references to the necessary accounts for executing this instruction.
    /// * `weights` - A vector of weights (u8) for the calculation. The length of this vector must not exceed 2.
    /// * `balances` - A vector of balances (u64) corresponding to the weights for the calculation. The length of this vector must match that of the `weights`.
    ///
    /// # Accounts
    ///
    /// * `user` - The user account. Acts as a placeholder in this context and is not directly used in calculations.
    ///
    /// # Process
    ///
    /// 1. Validates that the number of weights does not exceed 2. If it does, the function returns a `DataTooLarge` error.
    /// 2. Normalizes the weights and scales the balances according to a fixed scaling factor (for integration testing purposes).
    /// 3. Calculates the invariant using the normalized weights and scaled balances. If an error occurs during calculation, a `DataTooLarge` error is returned.
    /// 4. Logs the downscaled invariant to the console for inspection.
    ///
    /// # Important Notes
    ///
    /// - This function is intended for integration testing and not for production use.
    /// - It operates under the assumption that there are exactly two elements for weights and balances.
    /// - Error handling is primarily focused on the `DataTooLarge` scenario, which is triggered by having more than two weights or an error during the invariant calculation.
    pub fn calculate_invariant_instruction(
        ctx: Context<CalculateInvariant>,
        weights: Vec<u8>,
        balances: Vec<u64>,
    ) -> Result<()> {
        if weights.len() > 2 {
            return Err(NeptuneError::DataTooLarge.into());
        }
        let mut normalized_weights: [BigInt; 2] = [BigInt::from(0), BigInt::from(0)];
        let mut scaled_balances: [BigInt; 2] = [BigInt::from(0), BigInt::from(0)];
        for i in 0..weights.len() {
            normalized_weights[i] = math::WeightedMath::normalize_weight(weights[i]);
            let scale_factor = math::WeightedMath::get_scaling_factor(9u8);
            scaled_balances[i] = math::WeightedMath::scale_value(balances[i], scale_factor)
        }
        let invariant =
            match math::WeightedMath::calculate_invariant(&normalized_weights, &scaled_balances) {
                Ok(value) => value,
                Err(_math_err) => {
                    msg!("{:}", _math_err);
                    // Handle the error by returning an appropriate anchor_lang::error::Error
                    return Err(NeptuneError::DataTooLarge.into());
                }
            };
        msg!(
            "downscaled to  mintable amount  {:?}",
            math::WeightedMath::downscale_value(&invariant, 10u128.pow(9))
        );
        Ok(())
    }

    /// Initialize Pool
    ///
    /// Initializes a pool account with specified parameters, setting up the initial configuration for the pool, including timestamps, weights, token mints, and scaling factors. It also creates the necessary associated token accounts (ATAs) for fees.
    ///
    /// # Arguments
    ///
    /// * `ctx` - A Context object containing references to the accounts and programs required for pool initialization.
    /// * `params` - A struct containing the initialization parameters for the pool such as start and end timestamps, start and end weights.
    ///
    /// # Accounts
    ///
    /// * `user` - The user account acting as the signer and payer for the pool initialization.
    /// * `input_token_mint` - The mint account of the input token for the pool.
    /// * `output_token_mint` - The mint account of the output token for the pool.
    /// * `master_account` - The master account associated with the pool, providing configurations like fee percentages.
    /// * `master_account_input_fee_ata` - The ATA for depositing input token fees.
    /// * `master_account_output_fee_ata` - The ATA for depositing output token fees.
    /// * `pool_account` - The main account representing the pool, initialized with the provided parameters.
    /// * `bp_token_mint` - The mint for the pool's BP tokens, created during initialization.
    /// * `associated_token_program` - A reference to the Associated Token Program, used for managing ATAs.
    /// * `token_program` - A reference to the Token Program, used for token operations.
    /// * `system_program` - A reference to the System Program, used for account management.
    ///
    /// # Process
    ///
    /// 1. Validates the provided timestamps against the current time from the blockchain's clock to ensure they are in the future and the end timestamp is after the start timestamp.
    /// 2. Sets the pool account's basic configuration, including account type, timestamps, initial and final weights, swap fee percentage, and flat rate percentage from the master account.
    /// 3. Assigns token mints for input and output tokens, as well as the BP token mint created during the process.
    /// 4. Sets scaling factors based on the decimals of the input and output token mints.
    /// 5. Logs a message indicating the successful configuration of the pool.
    pub fn initialize_pool(
        ctx: Context<InitializePool>,
        params: InitializePoolParams,
    ) -> Result<()> {
        let pool_account = &mut ctx.accounts.pool_account;
        let clock = Clock::get()?;
        // clock.unix_timestamp is in second i64
        if clock.unix_timestamp >= params.end_timestamp
            || clock.unix_timestamp > params.start_timestamp
        {
            msg!(
                "Wring timestamp : {:?} < {:?} > {:?} ",
                clock.unix_timestamp,
                params.end_timestamp,
                params.start_timestamp
            );
            return Err(NeptuneError::InitParamError.into());
        }

        pool_account.account_type = 2;
        pool_account.start_timestamp = params.start_timestamp;
        pool_account.end_timestamp = params.end_timestamp;
        pool_account.start_weights = params.start_weights;
        pool_account.end_weights = params.end_weights;

        pool_account.is_vesting = params.is_vesting;
        pool_account.is_buy_only = params.is_buy_only;
        pool_account.swap_fee_percentage = ctx.accounts.master_account.protocol_swap_fee_percentage;
        pool_account.flat_rate_percentage =
            ctx.accounts.master_account.protocol_flat_rate_percentage;
        pool_account.scaling_factors[0] =
            math::WeightedMath::get_scaling_factor(ctx.accounts.input_token_mint.decimals);

        pool_account.input_token_mint = *ctx.accounts.input_token_mint.to_account_info().key;
        //msg!("params issol  {:?}", params.is_sol);

        if params.is_sol {
            pool_account.output_token_mint = Pubkey::default();
            msg!(" {:?}", pool_account.output_token_mint);
            pool_account.scaling_factors[1] =
                math::WeightedMath::get_scaling_factor(ctx.accounts.output_token_mint.decimals);
        } else {
            pool_account.output_token_mint = *ctx.accounts.output_token_mint.to_account_info().key;
            pool_account.scaling_factors[1] = math::WeightedMath::get_scaling_factor(6u8);
        }
        pool_account.owner = *ctx.accounts.user.to_account_info().key;
        // Update pool_account with ATA addresses
        pool_account.bp_token_mint = *ctx.accounts.bp_token_mint.to_account_info().key;
        //msg!("Pool {:?} Configured", pool_account.to_account_info().key);
        Ok(())
    }

    pub fn pause_pool(ctx: Context<PausePool>) -> Result<()> {
        let pool_account = &mut ctx.accounts.pool_account;
        if ctx.accounts.owner.to_account_info().key == &pool_account.owner {
            pool_account.swap_enabled = false;
        } else {
            return Err(NeptuneError::UnAuthorizedPoolOwner.into());
        }
        Ok(())
    }

    // If ct > end_time anybody can unpause
    pub fn unpause_pool(ctx: Context<UnPausePool>) -> Result<()> {
        let clock = Clock::get()?;
        let current_timestamp = clock.unix_timestamp;
        let pool_account = &mut ctx.accounts.pool_account;
        if current_timestamp > pool_account.end_timestamp {
            pool_account.swap_enabled = false;
        }
        if ctx.accounts.user.to_account_info().key == &pool_account.owner {
            pool_account.swap_enabled = false;
        }
        Ok(())
    }

    /// Initialize Pool Funds
    ///
    /// Prepares the pool for launch by transferring the initial token amounts into the pool's associated token accounts (ATAs) and minting the initial amount of BP tokens to be distributed to buyers. This operation includes checks on pool ownership, parameter validation, and calculation of the initial invariant.
    ///
    /// # Arguments
    ///
    /// * `ctx` - A Context object containing references to the accounts and programs required for initializing pool funds.
    /// * `params` - A struct containing the initial balances for the input and output tokens.
    ///
    /// # Accounts
    ///
    /// * `user` - The user account acting as the signer and payer for the operation, and must be the owner of the pool account.
    /// * `input_token_mint` - The mint account of the input token for the pool.
    /// * `output_token_mint` - The mint account of the output token for the pool.
    /// * `bp_token_mint` - The mint account for the pool's BP tokens.
    /// * `pool_account` - The main account representing the pool, whose funds are being initialized.
    /// * `user_input_ata` - The user's ATA for the input tokens.
    /// * `user_output_ata` - The user's ATA for the output tokens.
    /// * `user_bp_ata` - The ATA for the user's BP tokens, where minted BP tokens will be sent.
    /// * `pool_input_ata` - The pool's ATA for the input tokens.
    /// * `pool_output_ata` - The pool's ATA for the output tokens.
    /// * `associated_token_program` - A reference to the Associated Token Program, used for managing ATAs.
    /// * `token_program` - A reference to the Token Program, used for token operations.
    /// * `system_program` - A reference to the System Program, used for account management.
    ///
    /// # Process
    ///
    /// 1. Validates that the `user` is the owner of the `pool_account`.
    /// 2. Checks the length of the `params.balances` to ensure it matches the expected number of token types (2 in this case).
    /// 3. Calculates the invariant based on the provided start weights and initial balances, applying scaling factors as necessary.
    /// 4. Validates the calculated invariant to ensure it is within acceptable limits.
    /// 5. Transfers the specified amounts of input and output tokens from the user's ATAs to the pool's ATAs.
    /// 6. Mints BP tokens based on the calculated invariant and sends them to the user's BP ATA.
    /// 7. Logs the amount of BP tokens minted.
    /// 8. Updates the `pool_account`'s invariant to the calculated value.
    pub fn initialize_pool_funds(
        ctx: Context<InitializePoolFunds>,
        params: InitializePoolFundsParams,
    ) -> Result<()> {
        if ctx.accounts.pool_account.owner != *ctx.accounts.user.key {
            return Err(NeptuneError::UnAuthorizedPoolOwner.into());
        }
        let pool_account = &mut ctx.accounts.pool_account;

        if params.balances.len() != 2 {
            return Err(NeptuneError::InitParamError.into());
        }

        if pool_account.is_initialized {
            return Err(NeptuneError::InitParamError.into());
        }

        // 1st calculate the invariant
        // we want to  verify here that the tokensale does'nt exceed a certain amount
        // Since the Max token supply for 9 decimal is equal to 18446744073
        // And the max token supply for 8 decimal is equal to  184467440737
        let mut normalized_weights: [BigInt; 2] = [BigInt::from(0), BigInt::from(0)];
        let mut scaled_balances: [BigInt; 2] = [BigInt::from(0), BigInt::from(0)];
        // verify here paramaeter size just in case
        let weights: [u8; 2] = pool_account.start_weights;
        let balances: [u64; 2] = params.balances;
        for i in 0..weights.len() {
            normalized_weights[i] = math::WeightedMath::normalize_weight(weights[i]);
            scaled_balances[i] =
                math::WeightedMath::scale_value(balances[i], pool_account.scaling_factors[i])
        }

        let upscaled_invariant =
            match math::WeightedMath::calculate_invariant(&normalized_weights, &scaled_balances) {
                Ok(value) => value,
                Err(_math_err) => {
                    // Handle the error by returning an appropriate anchor_lang::error::Error
                    return Err(NeptuneError::MathError.into());
                }
            };
        let invariant =
            math::WeightedMath::downscale_value(&upscaled_invariant, 1000000000u128).unwrap();
        if invariant > 18446744073700000000 {
            return Err(NeptuneError::InitParamError.into());
        }
        if invariant < 100000000 {
            return Err(NeptuneError::InitParamError.into());
        }
        // Here we would also check if the ouput token is SOL, cause Sol are owned by Systemprogram and not Token program
        // Transfer input tokens from user to pool's input token ATA

        // Transfer input tokens from user to pool's input token ATA
        utils::transfer_router(
            false,
            Some(ctx.accounts.token_program.to_account_info()),
            ctx.accounts.user_input_ata.to_account_info(),
            Some(ctx.accounts.input_token_mint.to_account_info()),
            ctx.accounts.pool_input_ata.to_account_info(),
            Some(ctx.accounts.user.to_account_info()),
            None, //siger is user
            params.balances[0] as u64,
            Some(ctx.accounts.input_token_mint.decimals), // Assuming 9 decimals for simplicity; adjust as necessary
            None,                                         // Not used for SPL token transfers
        )?; // Set the initial BPT to the value of the invariant. (Eventually multiply with  the number of input tokens )
        if pool_account.output_token_mint != Pubkey::default() {
            // Perform SPL token transfer if the output token is not SOL
            utils::transfer_router(
                false, // Not a SOL transfer, it's an SPL token transfer
                Some(ctx.accounts.token_program.to_account_info()), // Token program for SPL transfer
                ctx.accounts.user_output_ata.to_account_info(), // Source account: User's output token ATA
                Some(ctx.accounts.output_token_mint.to_account_info()), // Mint account for SPL transfer
                ctx.accounts.pool_output_ata.to_account_info(), // Destination account: Pool's output token ATA
                Some(ctx.accounts.user.to_account_info()), // Authority account: User, as the signer
                None,                      // Signer seeds: None, direct signing by the user
                params.balances[1] as u64, // Amount: The amount of output tokens to transfer
                Some(ctx.accounts.output_token_mint.decimals), // Decimals: Mint's decimals for SPL token
                None, // System program not used for SPL token transfers
            )?;
        } else {
            msg!("permorming sol transfer{:?}", params);
            // Perform SOL transfer if the output token is indeed SOL
            utils::transfer_router(
                true,                                                // This is a SOL transfer
                None, // Token program not required for SOL
                ctx.accounts.user.to_account_info().clone(), // Source account: User's wallet for SOL
                None,                                        // Mint account not applicable for SOL
                pool_account.to_account_info(), // Destination: Pool's output account capable of receiving SOL
                Some(ctx.accounts.user.to_account_info()), // Authority: User, as the signer
                None,                           // Signer seeds: None, direct signing by the user
                params.balances[1],             // Amount: The SOL amount to transfer, in lamports
                None,                           // Decimals not applicable for SOL
                Some(ctx.accounts.system_program.to_account_info()), // System program required for SOL transfers
            )?;
        }

        let bpt_amount_out = invariant;
        msg!("bpt_amount_out {:?}%", bpt_amount_out);

        // tokens are minted to the owner's BP token ATA
        let mint_bp_tokens_cpi_accounts = MintTo {
            mint: ctx.accounts.bp_token_mint.to_account_info(),
            to: ctx.accounts.user_bp_ata.to_account_info(),
            authority: pool_account.to_account_info(),
        };
        let bump = ctx.bumps.pool_account;
        let bump_seed = [bump]; // Make sure bump is a single byte
        let seeds = &[
            b"pool_account",
            ctx.accounts.user.to_account_info().key.as_ref(),
            ctx.accounts.input_token_mint.to_account_info().key.as_ref(),
            &bump_seed[..], // Include the bump seed as part of the seeds array
        ];
        let signer: &[&[&[u8]]] = &[seeds];
        let mint_bp_tokens_cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            mint_bp_tokens_cpi_accounts,
            signer,
        );
        token::mint_to(mint_bp_tokens_cpi_ctx, bpt_amount_out)?;
        msg!("{:?} Bp token minted", bpt_amount_out);
        pool_account.invariant = bpt_amount_out;
        pool_account.is_initialized = true;
        pool_account.swap_enabled = true;
        Ok(())
    }

    /// Join Pool
    ///
    /// Allows the pool owner to add liquidity to the pool by depositing output tokens in exchange for BP tokens. This function handles the calculation of BP tokens to be minted to the owner based on the amount of output tokens added and the current state of the pool.
    ///
    /// # Arguments
    ///
    /// * `ctx` - A Context object containing references to the accounts and programs required for the owner to join the pool.
    /// * `amount_output_token` - The amount of output tokens the owner is depositing into the pool.
    ///
    /// # Accounts
    ///
    /// * `user` - The owner of the pool, acting as the signer for the transaction.
    /// * `user_output_ata` - The owner's associated token account for the output tokens.
    /// * `user_bp_ata` - The owner's associated token account for BP tokens, where minted BP tokens will be deposited.
    /// * `input_token_mint` - The mint account of the input token, used for deriving the pool account.
    /// * `pool_account` - The main account representing the pool, which tracks the pool's state and holdings.
    /// * `pool_input_ata` - The pool's associated token account for input tokens.
    /// * `pool_output_ata` - The pool's associated token account for output tokens.
    /// * `pool_bp_ata` - The pool's associated token account for BP tokens, holding the total supply of BP tokens.
    /// * `bp_token_mint` - The mint account for the pool's BP tokens.
    /// * `token_program` - A reference to the Token Program, used for token operations.
    ///
    /// # Process
    ///
    /// 1. Validates that the caller (`user`) is the owner of the `pool_account`.
    /// 2. Calculates the current weight percentages and balances for input and output tokens based on the progress between the pool's start and end timestamps.
    /// 3. Calculates the amount of BP tokens to be minted to the owner based on the deposited amount of output tokens and the current state of the pool.
    /// 4. Transfers the specified amount of output tokens from the owner's associated token account to the pool's associated token account for output tokens.
    /// 5. Mints the calculated amount of BP tokens to the owner's associated token account for BP tokens.
    /// 6. Logs the amount of BP tokens minted and the amount of output tokens received from the owner.
    pub fn join_pool(ctx: Context<JoinPool>, amount_output_token: u64) -> Result<()> {
        // only owner
        if ctx.accounts.pool_account.owner != *ctx.accounts.user.key {
            return Err(NeptuneError::UnAuthorizedPoolOwner.into());
        }
        let pool_account = &mut ctx.accounts.pool_account;

        // ISSUE here, calculating proto fees based on invariant growth reach the max compute limit
        // Issue updating invariant -> reaching max compute

        // 1- Calculate weight % change  depending on current_timestamp
        let clock = Clock::get()?;
        let current_timestamp = clock.unix_timestamp;
        let percent_progress = math::WeightedMath::calculate_weight_change_progress(
            current_timestamp,
            pool_account.start_timestamp,
            pool_account.end_timestamp,
        )?;
        //msg!("weight progress {:?}%", percent_progress);
        let current_input_weights = math::WeightedMath::interpolate_weight(
            pool_account.start_weights[0],
            pool_account.end_weights[0],
            percent_progress.try_into().unwrap(),
        )?;
        let current_output_weights = math::WeightedMath::interpolate_weight(
            pool_account.start_weights[1],
            pool_account.end_weights[1],
            percent_progress.try_into().unwrap(),
        )?;
        let current_weights = [
            math::WeightedMath::normalize_weight(current_input_weights),
            math::WeightedMath::normalize_weight(current_output_weights),
        ];
        let balances = [
            math::WeightedMath::scale_value(
                ctx.accounts.pool_input_ata.amount,
                pool_account.scaling_factors[0],
            ),
            math::WeightedMath::scale_value(
                ctx.accounts.pool_output_ata.amount,
                pool_account.scaling_factors[1],
            ),
        ];
        let amount_in = [
            BigInt::from(0),
            math::WeightedMath::scale_value(amount_output_token, pool_account.scaling_factors[0]),
        ];

        // 2- deduce the amountIn from protocol fees ...
        // We calculate Due protocol fee by measuring the the growth of the invariant between the previous join and now
        /* let invariant_before_join = calculate_invariant(&normalized_weights, &balances)
        let due_protocol_fee_amounts =  math::WeightedMath::_getDueProtocolFeeAmounts(
            balances, // based on the balances Before join
            current_weights, //
            maxWeightTokenIndex, // ^
            pool_account.invariant,
            invariant_before_join,
            pool_account.protocol_swap_fee_percentage
        );*/

        // 3- Calculate the amount of token out given the current balance and the amountIn
        let scaled_supply = BigInt::from(ctx.accounts.bp_token_mint.supply)
            .checked_mul(&BigInt::from(1 * 10u128.pow(18)))
            .unwrap(); //might be 28 not 18
        let amount_bp_tokens = math::WeightedMath::calc_bpt_out_given_exact_tokens_in(
            &balances,
            &current_weights,
            &amount_in,
            &scaled_supply,
            &BigInt::from(0),
        )
        .unwrap();
        //msg!("Calculated BPT token amount {:?}", amount_bp_tokens);

        if pool_account.output_token_mint != Pubkey::default() {
            // Perform SPL token transfer if the output token is not SOL
            utils::transfer_router(
                false, // Not a SOL transfer, it's an SPL token transfer
                Some(ctx.accounts.token_program.to_account_info()), // Token program for SPL transfer
                ctx.accounts.user_output_ata.to_account_info(), // Source account: User's output token ATA
                Some(ctx.accounts.output_token_mint.to_account_info()), // Mint account for SPL transfer
                ctx.accounts.pool_output_ata.to_account_info(), // Destination account: Pool's output token ATA
                Some(ctx.accounts.user.to_account_info()), // Authority account: User, as the signer
                None,                       // Signer seeds: None, direct signing by the user
                amount_output_token as u64, // Amount: The amount of output tokens to transfer
                Some(ctx.accounts.output_token_mint.decimals), // Decimals: Mint's decimals for SPL token
                None, // System program not used for SPL token transfers
            )?;
        } else {
            // Perform SOL transfer if the output token is indeed SOL
            utils::transfer_router(
                true,                                                // This is a SOL transfer
                None, // Token program not required for SOL
                ctx.accounts.user.to_account_info().clone(), // Source account: User's wallet for SOL
                None,                                        // Mint account not applicable for SOL
                pool_account.to_account_info(), // Destination: Pool's output account capable of receiving SOL
                Some(ctx.accounts.user.to_account_info()), // Authority: User, as the signer
                None,                           // Signer seeds: None, direct signing by the user
                amount_output_token,            // Amount: The SOL amount to transfer, in lamports
                None,                           // Decimals not applicable for SOL
                Some(ctx.accounts.system_program.to_account_info()), // System program required for SOL transfers
            )?;
        }
        //msg!("Amount  received from owner {:?}", amount_output_token);

        // Transfer BP tokens from the pool to the user
        let bump = ctx.bumps.pool_account;
        let bump_seed = [bump]; // Make sure bump is a single byte
                                // Bind the keys to variables to extend their lifetime
        let user_key = ctx.accounts.user.key();
        let input_token_mint_key = ctx.accounts.input_token_mint.key();
        // tokens are minted to the owner's BP token ATA
        let mint_bp_tokens_cpi_accounts = MintTo {
            mint: ctx.accounts.bp_token_mint.to_account_info(),
            to: ctx.accounts.user_bp_ata.to_account_info(),
            authority: pool_account.to_account_info(),
        };
        let bump = ctx.bumps.pool_account;
        let bump_seed = [bump]; // Make sure bump is a single byte
        let seeds = &[
            b"pool_account",
            ctx.accounts.user.to_account_info().key.as_ref(),
            ctx.accounts.input_token_mint.to_account_info().key.as_ref(),
            &bump_seed[..], // Include the bump seed as part of the seeds array
        ];
        let signer: &[&[&[u8]]] = &[seeds];
        let mint_bp_tokens_cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            mint_bp_tokens_cpi_accounts,
            signer,
        );
        token::mint_to(mint_bp_tokens_cpi_ctx, amount_bp_tokens)?;
        msg!("{:?} Bp token minted", amount_bp_tokens);
        Ok(())
    }
    /// Buy Swap
    ///
    /// Performs a token swap within the pool, allowing a user to exchange output tokens for input tokens, based on the current pool balances and token weights. This function also handles fee deduction and ensures the pool's invariant is maintained.
    ///
    /// # Arguments
    ///
    /// * `ctx` - A Context object containing references to the accounts and programs required for executing the swap.
    /// * `amount_output_token` - The amount of output tokens the user wishes to receive or the amount of input tokens the user wishes to provide, depending on the swap direction.
    /// * `is_given_in` - A boolean flag indicating the direction of the swap; `true` for input-to-output token swap, `false` for output-to-input.
    ///
    /// # Accounts
    ///
    /// * `owner` - The pool owner's account, used only for account derivation.
    /// * `master_account` - The master account associated with the pool, providing configurations like fee percentages.
    /// * `user` - The user performing the swap, acting as the signer.
    /// * `user_output_ata` - The user's associated token account for the output tokens.
    /// * `user_input_ata` - The user's associated token account for the input tokens.
    /// * `user_bp_ata` - The user's associated token account for BP tokens.
    /// * `input_token_mint` - The mint account of the input token for the pool.
    /// * `pool_account` - The main account representing the pool, which tracks the pool's state and holdings.
    /// * `pool_input_ata` - The pool's associated token account for input tokens.
    /// * `pool_output_ata` - The pool's associated token account for output tokens.
    /// * `pool_bp_ata` - The pool's associated token account for BP tokens, holding the total supply.
    /// * `fee_collector_input_ata` - The associated token account for collecting fees in input tokens.
    /// * `bp_token_mint` - The mint account for the pool's BP tokens.
    /// * `token_program` - A reference to the Token Program, used for token operations.
    /// * `associated_token_program` - A reference to the Associated Token Program, used for managing ATAs.
    /// * `system_program` - A reference to the System Program, used for account management.
    ///
    /// # Process
    ///
    /// 1. Validates that the current timestamp is within the pool's operational schedule.
    /// 2. Calculates the current weights for input and output tokens based on the elapsed time since the pool's start.
    /// 3. Determines the amount of tokens to be transferred based on the swap direction and calculates the due fees.
    /// 4. Performs the token transfer from the user to the pool and vice versa, adjusting for fees.
    /// 5. Transfers the calculated fees to the fee collector's associated token account.
    ///
    /// # Swap Directions
    ///
    /// - **Input to Output**: The user specifies the amount of input tokens to swap and receives a calculated amount of output tokens.
    /// - **Output to Input**: The user specifies the desired amount of output tokens and the function calculates the required amount of input tokens to be provided.
    pub fn buy_swap(ctx: Context<Swap>, amount_output_token: u64, is_given_in: bool) -> Result<()> {
        let clock = Clock::get()?;
        let current_timestamp = clock.unix_timestamp;
        let pool_account = &mut ctx.accounts.pool_account;
        if current_timestamp > pool_account.end_timestamp {
            return Err(NeptuneError::ScheduleFinalised.into());
        }
        if amount_output_token < 100 {
            return Err(NeptuneError::MinTokenAmountReached.into());
        }
        if !pool_account.swap_enabled {
            return Err(NeptuneError::OnPause.into());
        }
        // 1- Calculate weight % change depending on current_timestamp
        let percent_progress = math::WeightedMath::calculate_weight_change_progress(
            current_timestamp,
            pool_account.start_timestamp,
            pool_account.end_timestamp,
        )?;

        let current_input_weight = math::WeightedMath::interpolate_weight(
            pool_account.start_weights[0],
            pool_account.end_weights[0],
            percent_progress.try_into().unwrap(),
        )?;
        let current_output_weight = math::WeightedMath::interpolate_weight(
            pool_account.start_weights[1],
            pool_account.end_weights[1],
            percent_progress.try_into().unwrap(),
        )?;
        let current_weights = [
            math::WeightedMath::normalize_weight(current_input_weight),
            math::WeightedMath::normalize_weight(current_output_weight),
        ];

        // Assuming balances are retrieved similar to join_pool, adjust for swap context
        let balances = [
            math::WeightedMath::scale_value(
                ctx.accounts.pool_input_ata.amount,
                pool_account.scaling_factors[0],
            ),
            math::WeightedMath::scale_value(
                ctx.accounts.pool_output_ata.amount,
                pool_account.scaling_factors[1],
            ),
        ];
        let mut taxed_amount: u64 = 0u64;
        let mut due_fees: u64 = 0u64;
        let amount_scaled = if is_given_in {
            math::WeightedMath::scale_value(amount_output_token, pool_account.scaling_factors[1])
        } else {
            // For 'given out' swap, adjust logic accordingly let due_fees=  math::WeightedMath::calc_due_fee_amount(amount_output_token,pool_account.swap_fee_percentage);
            due_fees = math::WeightedMath::calc_due_fee_amount(
                amount_output_token,
                pool_account.swap_fee_percentage,
            );

            taxed_amount = amount_output_token - due_fees;
            math::WeightedMath::scale_value(taxed_amount, pool_account.scaling_factors[0])
            // Placeholder, adjust based on your logic for calculating 'amount_in' for 'given out' swaps
        };
        /*msg!(
            "Configs ok {:?} {:?} {:?} {:?} {:?}",
            balances[0],
            current_weights[0],
            balances[1],
            current_weights[1],
            amount_scaled
        );*/

        let bump = ctx.bumps.pool_account;
        let bump_seed = [bump]; // Make sure bump is a single byte

        if is_given_in {
            // in is XYZ
            // user params the amount of token he is ready to pay -> USDC
            // this answers how much  he can have
            let amount_out_upscaled = math::WeightedMath::calc_out_given_in(
                &balances[0],
                &current_weights[0],
                &balances[1],
                &current_weights[1],
                &amount_scaled,
            )
            .unwrap();
            let untaxed_amount_out = math::WeightedMath::downscale_value(
                &amount_out_upscaled,
                pool_account.scaling_factors[1],
            )
            .unwrap();
            due_fees = math::WeightedMath::calc_due_fee_amount(
                untaxed_amount_out,
                pool_account.swap_fee_percentage,
            );
            let amount_out = untaxed_amount_out - due_fees;
            //msg!("amount out {:?}%", amount_out.clone());
            if pool_account.output_token_mint != Pubkey::default() {
                // Perform SPL token transfer if the output token is not SOL
                utils::transfer_router(
                    false, // Not a SOL transfer, it's an SPL token transfer
                    Some(ctx.accounts.token_program.to_account_info()), // Token program for SPL transfer
                    ctx.accounts.user_output_ata.to_account_info(), // Source account: User's output token ATA
                    Some(ctx.accounts.output_token_mint.to_account_info()), // Mint account for SPL transfer
                    ctx.accounts.pool_output_ata.to_account_info(), // Destination account: Pool's output token ATA
                    Some(ctx.accounts.user.to_account_info()), // Authority account: User, as the signer
                    None,                       // Signer seeds: None, direct signing by the user
                    amount_output_token as u64, // Amount: The amount of output tokens to transfer
                    Some(ctx.accounts.output_token_mint.decimals), // Decimals: Mint's decimals for SPL token
                    None, // System program not used for SPL token transfers
                )?;
            } else {
                // Perform SOL transfer if the output token is indeed SOL
                utils::transfer_router(
                    true,                                                // This is a SOL transfer
                    None, // Token program not required for SOL
                    ctx.accounts.user.to_account_info().clone(), // Source account: User's wallet for SOL
                    None,                           // Mint account not applicable for SOL
                    pool_account.to_account_info(), // Destination: Pool's output account capable of receiving SOL
                    Some(ctx.accounts.user.to_account_info()), // Authority: User, as the signer
                    None,                // Signer seeds: None, direct signing by the user
                    amount_output_token, // Amount: The SOL amount to transfer, in lamports
                    None,                // Decimals not applicable for SOL
                    Some(ctx.accounts.system_program.to_account_info()), // System program required for SOL transfers
                )?;
            }
            //msg!("User transfer received ");

            let seeds = &[
                b"pool_account",
                ctx.accounts.owner.to_account_info().key.as_ref(),
                ctx.accounts.input_token_mint.to_account_info().key.as_ref(),
                &bump_seed[..], // Include the bump seed as part of the seeds array
            ];
            let signer: &[&[&[u8]]] = &[seeds];

            let transfer_input_cpi_accounts = Transfer {
                from: ctx.accounts.pool_input_ata.to_account_info(),
                to: ctx.accounts.user_input_ata.to_account_info(),
                authority: ctx.accounts.pool_account.to_account_info(),
            };
            // So we make a transfer where amount_in is the amount of token he is paying
            let transfer_input_cpi_ctx = CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                transfer_input_cpi_accounts,
                signer,
            );
            token::transfer(transfer_input_cpi_ctx, amount_out)?;
            let transfer_fees_cpi_accounts = Transfer {
                from: ctx.accounts.pool_input_ata.to_account_info(),
                to: ctx.accounts.fee_collector_input_ata.to_account_info(),
                authority: ctx.accounts.pool_account.to_account_info(),
            };

            let transfer_fees_cpi_ctx = CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                transfer_fees_cpi_accounts,
                signer,
            );
            token::transfer(transfer_fees_cpi_ctx, due_fees)?;
        } else {
            // user params the amount of token he wants to have -> XYZ
            // this answer how much he needs to pay in USDC
            let amount_in_upscaled = math::WeightedMath::calc_in_given_out(
                &balances[0],
                &current_weights[0],
                &balances[1],
                &current_weights[1],
                &amount_scaled,
            )
            .unwrap();
            let amount_in = math::WeightedMath::downscale_value(
                &amount_in_upscaled,
                pool_account.scaling_factors[0],
            );

            //msg!("amount in {:?}%", amount_in.clone());
            if pool_account.output_token_mint != Pubkey::default() {
                // Perform SPL token transfer if the output token is not SOL
                utils::transfer_router(
                    false, // Not a SOL transfer, it's an SPL token transfer
                    Some(ctx.accounts.token_program.to_account_info()), // Token program for SPL transfer
                    ctx.accounts.user_output_ata.to_account_info(), // Source account: User's output token ATA
                    Some(ctx.accounts.output_token_mint.to_account_info()), // Mint account for SPL transfer
                    ctx.accounts.pool_output_ata.to_account_info(), // Destination account: Pool's output token ATA
                    Some(ctx.accounts.user.to_account_info()), // Authority account: User, as the signer
                    None,               // Signer seeds: None, direct signing by the user
                    amount_in.unwrap(), // Amount: The amount of output tokens to transfer
                    Some(ctx.accounts.output_token_mint.decimals), // Decimals: Mint's decimals for SPL token
                    None, // System program not used for SPL token transfers
                )?;
            } else {
                // Perform SOL transfer if the output token is indeed SOL
                utils::transfer_router(
                    true,                                                // This is a SOL transfer
                    None, // Token program not required for SOL
                    ctx.accounts.user.to_account_info().clone(), // Source account: User's wallet for SOL
                    None,                           // Mint account not applicable for SOL
                    pool_account.to_account_info(), // Destination: Pool's output account capable of receiving SOL
                    Some(ctx.accounts.user.to_account_info()), // Authority: User, as the signer
                    None,               // Signer seeds: None, direct signing by the user
                    amount_in.unwrap(), // Amount: The SOL amount to transfer, in lamports
                    None,               // Decimals not applicable for SOL
                    Some(ctx.accounts.system_program.to_account_info()), // System program required for SOL transfers
                )?;
            }
            let seeds = &[
                b"pool_account",
                ctx.accounts.owner.to_account_info().key.as_ref(),
                ctx.accounts.input_token_mint.to_account_info().key.as_ref(),
                &bump_seed[..], // Include the bump seed as part of the seeds array
            ];
            let signer: &[&[&[u8]]] = &[seeds];

            let transfer_input_cpi_accounts = Transfer {
                from: ctx.accounts.pool_input_ata.to_account_info(),
                to: ctx.accounts.user_input_ata.to_account_info(),
                authority: ctx.accounts.pool_account.to_account_info(),
            };
            // So we make a transfer where amount is the amount of token he is paying
            let transfer_input_cpi_ctx = CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                transfer_input_cpi_accounts,
                signer,
            );
            token::transfer(transfer_input_cpi_ctx, amount_output_token)?;
            let transfer_fees_cpi_accounts = Transfer {
                from: ctx.accounts.pool_input_ata.to_account_info(),
                to: ctx.accounts.fee_collector_input_ata.to_account_info(),
                authority: ctx.accounts.pool_account.to_account_info(),
            };

            let transfer_fees_cpi_ctx = CpiContext::new_with_signer(
                ctx.accounts.token_program.to_account_info(),
                transfer_fees_cpi_accounts,
                signer,
            );
            token::transfer(transfer_fees_cpi_ctx, due_fees)?;
        }

        Ok(())
    }

    /// Sell Swap
    ///
    /// Performs a token swap within the pool, allowing a user to exchange input tokens for output tokens, based on the current pool balances and token weights. This function also handles fee deduction and ensures the pool's invariant is maintained.
    ///
    /// # Arguments
    ///
    /// * `ctx` - A Context object containing references to the accounts and programs required for executing the swap.
    /// * `amount_output_token` - The amount of output tokens the user wishes to receive or the amount of input tokens the user wishes to provide, depending on the swap direction.
    /// * `is_given_in` - A boolean flag indicating the direction of the swap; `true` for input-to-output token swap, `false` for output-to-input.
    ///
    /// # Accounts
    ///
    /// * `owner` - The pool owner's account, used only for account derivation.
    /// * `master_account` - The master account associated with the pool, providing configurations like fee percentages.
    /// * `user` - The user performing the swap, acting as the signer.
    /// * `user_output_ata` - The user's associated token account for the output tokens.
    /// * `user_input_ata` - The user's associated token account for the input tokens.
    /// * `user_bp_ata` - The user's associated token account for BP tokens.
    /// * `input_token_mint` - The mint account of the input token for the pool.
    /// * `pool_account` - The main account representing the pool, which tracks the pool's state and holdings.
    /// * `pool_input_ata` - The pool's associated token account for input tokens.
    /// * `pool_output_ata` - The pool's associated token account for output tokens.
    /// * `pool_bp_ata` - The pool's associated token account for BP tokens, holding the total supply.
    /// * `fee_collector_input_ata` - The associated token account for collecting fees in input tokens.
    /// * `bp_token_mint` - The mint account for the pool's BP tokens.
    /// * `token_program` - A reference to the Token Program, used for token operations.
    /// * `associated_token_program` - A reference to the Associated Token Program, used for managing ATAs.
    /// * `system_program` - A reference to the System Program, used for account management.
    ///
    /// # Process
    ///
    /// 1. Validates that the current timestamp is within the pool's operational schedule.
    /// 2. Calculates the current weights for input and output tokens based on the elapsed time since the pool's start.
    /// 3. Determines the amount of tokens to be transferred based on the swap direction and calculates the due fees.
    /// 4. Performs the token transfer from the user to the pool and vice versa, adjusting for fees.
    /// 5. Transfers the calculated fees to the fee collector's associated token account.
    ///
    /// # Swap Directions
    ///
    /// - **Input to Output**: The user specifies the amount of input tokens to swap and receives a calculated amount of output tokens.
    /// - **Output to Input**: The user specifies the desired amount of output tokens and the function calculates the required amount of input tokens to be provided.
    pub fn sell_swap(ctx: Context<Swap>, amount_input_token: u64, is_given_in: bool) -> Result<()> {
        let clock = Clock::get()?;
        let current_timestamp = clock.unix_timestamp;
        let pool_account = &mut ctx.accounts.pool_account;
        if current_timestamp > pool_account.end_timestamp {
            return Err(NeptuneError::ScheduleFinalised.into());
        }
        if amount_input_token < 100 {
            return Err(NeptuneError::MinTokenAmountReached.into());
        }
        if !pool_account.swap_enabled {
            return Err(NeptuneError::OnPause.into());
        }
        if !pool_account.is_buy_only {
            return Err(NeptuneError::BuyOnly.into());
        }
        // 1- Calculate weight % change depending on current_timestamp
        let percent_progress = math::WeightedMath::calculate_weight_change_progress(
            current_timestamp,
            pool_account.start_timestamp,
            pool_account.end_timestamp,
        )?;

        let current_input_weight = math::WeightedMath::interpolate_weight(
            pool_account.start_weights[0],
            pool_account.end_weights[0],
            percent_progress.try_into().unwrap(),
        )?;
        let current_output_weight = math::WeightedMath::interpolate_weight(
            pool_account.start_weights[1],
            pool_account.end_weights[1],
            percent_progress.try_into().unwrap(),
        )?;
        let current_weights = [
            math::WeightedMath::normalize_weight(current_input_weight),
            math::WeightedMath::normalize_weight(current_output_weight),
        ];

        // Assuming balances are retrieved similar to join_pool, adjust for swap context
        let balances = [
            math::WeightedMath::scale_value(
                ctx.accounts.pool_input_ata.amount,
                pool_account.scaling_factors[0],
            ),
            math::WeightedMath::scale_value(
                ctx.accounts.pool_output_ata.amount,
                pool_account.scaling_factors[1],
            ),
        ];
        let mut taxed_amount: u64 = 0u64;
        let mut due_fees: u64 = 0u64;
        let mut taxed_amount: u64 = 0u64;
        let mut due_fees: u64 = 0u64;
        let amount_scaled = if is_given_in {
            // user params the amount of token he is ready to pay -> XYZ
            // so we take fees on that
            due_fees = math::WeightedMath::calc_due_fee_amount(
                amount_input_token,
                pool_account.swap_fee_percentage,
            );
            taxed_amount = amount_input_token - due_fees;
            math::WeightedMath::scale_value(taxed_amount, pool_account.scaling_factors[0])
        } else {
            // user params the amount of token wants to have -> USDC
            // so we take fees later when we calculate how much comes out
            math::WeightedMath::scale_value(amount_input_token, pool_account.scaling_factors[1])
            // Placeholder, adjust based on your logic for calculating 'amount_in' for 'given out' swaps
        };
        /*msg!(
            "Configs ok {:?} {:?} {:?} {:?} {:?}",
            balances[0],
            current_weights[0],
            balances[1],
            current_weights[1],
            amount_scaled
        );*/

        let bump = ctx.bumps.pool_account;
        let bump_seed = [bump]; // Make sure bump is a single byte

        if is_given_in {
            // in is XYZ
            // user params the amount of token he is ready to pay -> XYZ
            // this answers how much  he can have amount_out is -> USDC
            let amount_out_upscaled = math::WeightedMath::calc_out_given_in(
                &balances[1],
                &current_weights[1],
                &balances[0],
                &current_weights[0],
                &amount_scaled,
            )
            .unwrap();
            let amount_out = math::WeightedMath::downscale_value(
                &amount_out_upscaled,
                pool_account.scaling_factors[1],
            );
            //msg!("amount out {:?}%", amount_out.clone());
            // Perform SPL token transfer  the output token is not SOL
            utils::transfer_router(
                false, // Not a SOL transfer, it's an SPL token transfer
                Some(ctx.accounts.token_program.to_account_info()), // Token program for SPL transfer
                ctx.accounts.user_input_ata.to_account_info(), // Source account: User's output token ATA
                Some(ctx.accounts.input_token_mint.to_account_info()), // Mint account for SPL transfer
                ctx.accounts.pool_input_ata.to_account_info(), // Destination account: Pool's output token ATA
                Some(ctx.accounts.user.to_account_info()), // Authority account: User, as the signer
                None,                // Signer seeds: None, direct signing by the user
                taxed_amount as u64, // Amount: The amount of output tokens to transfer
                Some(ctx.accounts.input_token_mint.decimals), // Decimals: Mint's decimals for SPL token
                None, // System program not used for SPL token transfers
            )?;

            //msg!("User transfer received ");

            let seeds = &[
                b"pool_account",
                ctx.accounts.owner.to_account_info().key.as_ref(),
                ctx.accounts.input_token_mint.to_account_info().key.as_ref(),
                &bump_seed[..], // Include the bump seed as part of the seeds array
            ];
            let signer: &[&[&[u8]]] = &[seeds];

            if pool_account.output_token_mint != Pubkey::default() {
                // Perform SPL token transfer if the output token is not SOL
                utils::transfer_router(
                    false, // Not a SOL transfer, it's an SPL token transfer
                    Some(ctx.accounts.token_program.to_account_info()), // Token program for SPL transfer
                    ctx.accounts.pool_output_ata.to_account_info(), // Source account: User's output token ATA
                    Some(ctx.accounts.output_token_mint.to_account_info()), // Mint account for SPL transfer
                    ctx.accounts.user_output_ata.to_account_info(), // Destination account: Pool's output token ATA
                    Some(ctx.accounts.pool_account.to_account_info()), // Authority account: User, as the signer
                    Some(signer), // Signer seeds: None, direct signing by the user
                    amount_out.unwrap(), // Amount: The amount of output tokens to transfer
                    Some(ctx.accounts.output_token_mint.decimals), // Decimals: Mint's decimals for SPL token
                    None, // System program not used for SPL token transfers
                )?;
            } else {
                // Perform SOL transfer if the output token is indeed SOL
                utils::transfer_router(
                    true,                                                // This is a SOL transfer
                    None, // Token program not required for SOL
                    ctx.accounts.pool_account.to_account_info().clone(), // Source account: User's wallet for SOL
                    None,                                // Mint account not applicable for SOL
                    ctx.accounts.user.to_account_info(), // Destination: Pool's output account capable of receiving SOL
                    Some(ctx.accounts.pool_account.to_account_info()), // Authority: User, as the signer
                    Some(signer), // Signer seeds: None, direct signing by the user
                    amount_out.unwrap(), // Amount: The SOL amount to transfer, in lamports
                    None,         // Decimals not applicable for SOL
                    Some(ctx.accounts.system_program.to_account_info()), // System program required for SOL transfers
                )?;
            }

            // Perform SPL token transfer  the output token is not SOL
            utils::transfer_router(
                false, // Not a SOL transfer, it's an SPL token transfer
                Some(ctx.accounts.token_program.to_account_info()), // Token program for SPL transfer
                ctx.accounts.user_input_ata.to_account_info(), // Source account: User's output token ATA
                Some(ctx.accounts.input_token_mint.to_account_info()), // Mint account for SPL transfer
                ctx.accounts.fee_collector_input_ata.to_account_info(), // Destination account: Pool's output token ATA
                Some(ctx.accounts.pool_account.to_account_info()), // Authority account: User, as the signer
                None,            // Signer seeds: None, direct signing by the user
                due_fees as u64, // Amount: The amount of output tokens to transfer
                Some(ctx.accounts.input_token_mint.decimals), // Decimals: Mint's decimals for SPL token
                None, // System program not used for SPL token transfers
            )?;
        } else {
            // user params the amount of token he wants to have -> USDC
            // this answer how much he needs to pay -> XYZ
            let amount_out_upscaled = math::WeightedMath::calc_in_given_out(
                &balances[1],
                &current_weights[1],
                &balances[0],
                &current_weights[0],
                &amount_scaled,
            )
            .unwrap();
            let untaxed_amount_out = math::WeightedMath::downscale_value(
                &amount_out_upscaled,
                pool_account.scaling_factors[0],
            )
            .unwrap();
            due_fees = math::WeightedMath::calc_due_fee_amount(
                amount_input_token,
                pool_account.swap_fee_percentage,
            );
            let amount_in = untaxed_amount_out - due_fees;

            //msg!("amount in {:?}%", amount_in.clone());
            // Perform SPL token transfer if the input token is not SOL
            utils::transfer_router(
                false, // Not a SOL transfer, it's an SPL token transfer
                Some(ctx.accounts.token_program.to_account_info()), // Token program for SPL transfer
                ctx.accounts.user_input_ata.to_account_info(), // Source account: User's output token ATA
                Some(ctx.accounts.input_token_mint.to_account_info()), // Mint account for SPL transfer
                ctx.accounts.pool_input_ata.to_account_info(), // Destination account: Pool's output token ATA
                Some(ctx.accounts.user.to_account_info()), // Authority account: User, as the signer
                None,      // Signer seeds: None, direct signing by the user
                amount_in, // Amount: The amount of output tokens to transfer
                Some(ctx.accounts.output_token_mint.decimals), // Decimals: Mint's decimals for SPL token
                None, // System program not used for SPL token transfers
            )?;

            let seeds = &[
                b"pool_account",
                ctx.accounts.owner.to_account_info().key.as_ref(),
                ctx.accounts.input_token_mint.to_account_info().key.as_ref(),
                &bump_seed[..], // Include the bump seed as part of the seeds array
            ];
            let signer: &[&[&[u8]]] = &[seeds];
            if pool_account.output_token_mint != Pubkey::default() {
                // Perform SPL token transfer if the output token is not SOL
                utils::transfer_router(
                    false, // Not a SOL transfer, it's an SPL token transfer
                    Some(ctx.accounts.token_program.to_account_info()), // Token program for SPL transfer
                    ctx.accounts.pool_output_ata.to_account_info(), // Source account: User's output token ATA
                    Some(ctx.accounts.output_token_mint.to_account_info()), // Mint account for SPL transfer
                    ctx.accounts.user_output_ata.to_account_info(), // Destination account: Pool's output token ATA
                    Some(ctx.accounts.pool_account.to_account_info()), // Authority account: User, as the signer
                    Some(signer),       // Signer seeds: None, direct signing by the user
                    amount_input_token, // Amount: The amount of output tokens to transfer
                    Some(ctx.accounts.output_token_mint.decimals), // Decimals: Mint's decimals for SPL token
                    None, // System program not used for SPL token transfers
                )?;
            } else {
                // Perform SOL transfer if the output token is indeed SOL
                utils::transfer_router(
                    true,                                                // This is a SOL transfer
                    None, // Token program not required for SOL
                    ctx.accounts.pool_account.to_account_info().clone(), // Source account: User's wallet for SOL
                    None,                                // Mint account not applicable for SOL
                    ctx.accounts.user.to_account_info(), // Destination: Pool's output account capable of receiving SOL
                    Some(ctx.accounts.pool_account.to_account_info()), // Authority: User, as the signer
                    Some(signer),       // Signer seeds: None, direct signing by the user
                    amount_input_token, // Amount: The SOL amount to transfer, in lamports
                    None,               // Decimals not applicable for SOL
                    Some(ctx.accounts.system_program.to_account_info()), // System program required for SOL transfers
                )?;
            }
            // Perform SPL token transfer if the input token is not SOL
            utils::transfer_router(
                false, // Not a SOL transfer, it's an SPL token transfer
                Some(ctx.accounts.token_program.to_account_info()), // Token program for SPL transfer
                ctx.accounts.user_input_ata.to_account_info(), // Source account: User's output token ATA
                Some(ctx.accounts.input_token_mint.to_account_info()), // Mint account for SPL transfer
                ctx.accounts.fee_collector_input_ata.to_account_info(), // Destination account: Pool's output token ATA
                Some(ctx.accounts.user.to_account_info()), // Authority account: User, as the signer
                None,     // Signer seeds: None, direct signing by the user
                due_fees, // Amount: The amount of output tokens to transfer
                Some(ctx.accounts.output_token_mint.decimals), // Decimals: Mint's decimals for SPL token
                None, // System program not used for SPL token transfers
            )?;
        }

        Ok(())
    }

    /// Redeem BP Tokens
    ///
    /// Allows users to redeem their BP tokens for a proportional share of the pool's underlying assets once the pool is finalized. This operation includes the distribution of both input and output tokens relative to the BP tokens redeemed, less any applicable fees.
    ///
    /// # Arguments
    ///
    /// * `ctx` - A Context object containing references to the accounts and programs required for redeeming BP tokens.
    /// * `amount_bp_token` - The amount of BP tokens the user wishes to redeem.
    ///
    /// # Accounts
    ///
    /// * `user` - The user performing the redemption, acting as the signer.
    /// * `user_bp_ata` - The user's associated token account for BP tokens.
    /// * `user_input_ata` - The user's associated token account for the pool's input tokens.
    /// * `user_output_ata` - The user's associated token account for the pool's output tokens.
    /// * `pool_account` - The main account representing the pool, which tracks the pool's state and holdings.
    /// * `pool_input_ata` - The pool's associated token account for input tokens.
    /// * `pool_output_ata` - The pool's associated token account for output tokens.
    /// * `pool_bp_ata` - The pool's associated token account for BP tokens, holding the total supply.
    /// * `bp_token_mint` - The mint account for the pool's BP tokens.
    /// * `fee_collector_output_ata` - The associated token account for collecting fees in output tokens.
    /// * `token_program` - A reference to the Token Program, used for token operations.
    /// * `associated_token_program` - A reference to the Associated Token Program, used for managing ATAs.
    /// * `system_program` - A reference to the System Program, used for account management.
    ///
    /// # Process
    ///
    /// 1. Verifies that the pool's schedule is finalized based on the current blockchain timestamp.
    /// 2. Calculates the user's proportional share of the pool's input and output tokens based on the amount of BP tokens being redeemed.
    /// 3. Deducts applicable fees from the output tokens before distribution to the user.
    /// 4. Transfers the BP tokens from the user to the pool, effectively removing them from circulation.
    /// 5. Distributes the calculated amounts of input and output tokens to the user, less any fees.
    /// 6. Transfers the calculated fee to the fee collector's associated token account.
    /// 7. Burns the redeemed BP tokens to reduce the total supply accordingly.
    pub fn redeem_bp_tokens(ctx: Context<Redeem>, amount_bp_token: u64) -> Result<()> {
        // verify first if poolstate is finalized
        let clock = Clock::get()?;
        let current_timestamp = clock.unix_timestamp;
        let pool_account = &mut ctx.accounts.pool_account;
        if current_timestamp < pool_account.end_timestamp {
            return Err(NeptuneError::ScheduleNotFinalised.into());
        }
        let balances = [
            math::WeightedMath::scale_value(
                ctx.accounts.pool_input_ata.amount,
                pool_account.scaling_factors[0],
            ),
            math::WeightedMath::scale_value(
                ctx.accounts.pool_output_ata.amount,
                pool_account.scaling_factors[1],
            ),
        ];
        let supply = math::WeightedMath::scale_value(
            ctx.accounts.bp_token_mint.supply,
            math::WeightedMath::get_scaling_factor(ctx.accounts.bp_token_mint.decimals),
        );
        let scaled_bp_amount = math::WeightedMath::scale_value(
            amount_bp_token,
            math::WeightedMath::get_scaling_factor(ctx.accounts.bp_token_mint.decimals),
        );
        // Calculate the amount of input tokens to transfer
        // Simplified to 1:1 conversion for testing transfer behaviors
        let amounts = math::WeightedMath::compute_proportional_amounts_out(
            &balances,
            &supply,
            &scaled_bp_amount,
        )
        .unwrap();
        // We need to downscale here
        let amount_input_tokens =
            math::WeightedMath::downscale_value(&amounts[0], pool_account.scaling_factors[0])
                .unwrap();
        let untaxed_amount_output_tokens =
            math::WeightedMath::downscale_value(&amounts[1], pool_account.scaling_factors[1])
                .unwrap();
        let due_fees = math::WeightedMath::calc_due_fee_amount(
            untaxed_amount_output_tokens,
            pool_account.flat_rate_percentage,
        );
        let amount_output_tokens = untaxed_amount_output_tokens - due_fees;
        /*msg!(
            "For {:?} the user will  receive {:?}inT {:?}outT ",
            amount_bp_token,
            amount_input_tokens,
            amount_output_tokens
        );*/

        // Transfer bp tokens from the user to the pool
        let transfer_bp_cpi_accounts = Transfer {
            from: ctx.accounts.user_bp_ata.to_account_info(),
            to: ctx.accounts.pool_bp_ata.to_account_info(),
            authority: ctx.accounts.user.to_account_info(),
        };
        let transfer_bp_cpi_ctx = CpiContext::new(
            ctx.accounts.token_program.to_account_info(),
            transfer_bp_cpi_accounts,
        );
        token::transfer(transfer_bp_cpi_ctx, amount_bp_token)?;

        // Transfer tokens from the pool to the user
        let bump = ctx.bumps.pool_account;
        let bump_seed = [bump]; // Make sure bump is a single byte
                                // Bind the keys to variables to extend their lifetime
        let user_key = ctx.accounts.user.key();
        let input_token_mint_key = ctx.accounts.input_token_mint.key();
        let seeds = &[
            b"pool_account",
            ctx.accounts.owner.to_account_info().key.as_ref(),
            ctx.accounts.input_token_mint.to_account_info().key.as_ref(),
            &bump_seed[..], // Include the bump seed as part of the seeds array
        ];
        let signer: &[&[&[u8]]] = &[seeds];

        let transfer_input_cpi_accounts = Transfer {
            from: ctx.accounts.pool_input_ata.to_account_info(),
            to: ctx.accounts.user_input_ata.to_account_info(),
            authority: pool_account.to_account_info(),
        };

        let transfer_input_cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            transfer_input_cpi_accounts,
            signer,
        );
        token::transfer(transfer_input_cpi_ctx, amount_input_tokens)?;

        if pool_account.output_token_mint != Pubkey::default() {
            // Perform SPL token transfer if the output token is not SOL
            utils::transfer_router(
                false, // Not a SOL transfer, it's an SPL token transfer
                Some(ctx.accounts.token_program.to_account_info()), // Token program for SPL transfer
                ctx.accounts.pool_output_ata.to_account_info(), // Destination account: Pool's output token ATA
                // Source account: User's output token ATA
                Some(ctx.accounts.output_token_mint.to_account_info()), // Mint account for SPL transfer
                ctx.accounts.user_output_ata.to_account_info(),
                Some(pool_account.to_account_info()), // Authority account: User, as the signer
                Some(signer),         // Signer seeds: None, direct signing by the user
                amount_output_tokens, // Amount: The amount of output tokens to transfer
                Some(ctx.accounts.output_token_mint.decimals), // Decimals: Mint's decimals for SPL token
                None, // System program not used for SPL token transfers
            )?;
        } else {
            // Perform SOL transfer if the output token is indeed SOL
            utils::transfer_router(
                true, // This is a SOL transfer
                None, // Token program not required for SOL
                pool_account.to_account_info(),
                // Source account: User's wallet for SOL
                None, // Mint account not applicable for SOL
                ctx.accounts.user.to_account_info().clone(),
                // Destination: Pool's output account capable of receiving SOL
                Some(pool_account.to_account_info()), // Authority: User, as the signer
                Some(signer),         // Signer seeds: None, direct signing by the user
                amount_output_tokens, // Amount: The SOL amount to transfer, in lamports
                None,                 // Decimals not applicable for SOL
                Some(ctx.accounts.system_program.to_account_info()), // System program required for SOL transfers
            )?;
        }
        if pool_account.output_token_mint != Pubkey::default() {
            // Perform SPL token transfer if the output token is not SOL
            utils::transfer_router(
                false, // Not a SOL transfer, it's an SPL token transfer
                Some(ctx.accounts.token_program.to_account_info()), // Token program for SPL transfer
                ctx.accounts.pool_output_ata.to_account_info(), // Destination account: Pool's output token ATA
                // Source account: User's output token ATA
                Some(ctx.accounts.output_token_mint.to_account_info()), // Mint account for SPL transfer
                ctx.accounts.fee_collector_output_ata.to_account_info(),
                Some(pool_account.to_account_info()), // Authority account: User, as the signer
                Some(signer), // Signer seeds: None, direct signing by the user
                due_fees,     // Amount: The amount of output tokens to transfer
                Some(ctx.accounts.output_token_mint.decimals), // Decimals: Mint's decimals for SPL token
                None, // System program not used for SPL token transfers
            )?;
        } else {
            // Perform SOL transfer if the output token is indeed SOL
            utils::transfer_router(
                true, // This is a SOL transfer
                None, // Token program not required for SOL
                pool_account.to_account_info(),
                // Source account: User's wallet for SOL
                None, // Mint account not applicable for SOL
                ctx.accounts.fee_collector_output_ata.to_account_info(),
                // Destination: Pool's output account capable of receiving SOL
                Some(pool_account.to_account_info()), // Authority: User, as the signer
                Some(signer), // Signer seeds: None, direct signing by the user
                due_fees,     // Amount: The SOL amount to transfer, in lamports
                None,         // Decimals not applicable for SOL
                Some(ctx.accounts.system_program.to_account_info()), // System program required for SOL transfers
            )?;
        }

        let transfer_output_cpi_accounts = Burn {
            mint: ctx.accounts.bp_token_mint.to_account_info(),
            from: ctx.accounts.pool_bp_ata.to_account_info(),
            authority: ctx.accounts.pool_account.to_account_info(),
        };

        let transfer_output_cpi_ctx = CpiContext::new_with_signer(
            ctx.accounts.token_program.to_account_info(),
            transfer_output_cpi_accounts,
            signer,
        );
        token::burn(transfer_output_cpi_ctx, amount_bp_token)?;
        Ok(())
    }
}

#[error_code]
pub enum NeptuneError {
    #[msg("MyAccount may only hold data below 100")]
    DataTooLarge,
    #[msg("Incorrect initialisation parameter")]
    InitParamError,
    #[msg("An overflow was detected")]
    MathError,
    #[msg("Unhauthorized access")]
    UnAuthorizedPoolOwner,
    #[msg("Pool Schedule not finalized")]
    ScheduleNotFinalised,
    #[msg("Pool Schedule already finalized")]
    ScheduleFinalised,
    #[msg("Pool was paused")]
    OnPause,
    #[msg("Pool is Buy only")]
    BuyOnly,
    #[msg("Amount too low")]
    MinTokenAmountReached,
}
